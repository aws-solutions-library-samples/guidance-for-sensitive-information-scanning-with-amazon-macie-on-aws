{
  "version": 3,
  "sources": ["../../lib/lambda/process-macie-job-status/index.ts", "../../lib/lambda/process-macie-job-status/utils/event-processor.ts", "../../lib/lambda/process-macie-job-status/types/cloudwatch-logs-event.ts", "../../lib/lambda/shared/utils/logger.ts", "../../lib/lambda/shared/utils/eventbridge-validator.ts"],
  "sourcesContent": ["import { Context } from 'aws-lambda';\nimport { Macie2Client, DescribeClassificationJobCommand } from '@aws-sdk/client-macie2';\nimport { EventBridgeClient, PutEventsCommand } from '@aws-sdk/client-eventbridge';\nimport { \n  CloudWatchLogsEvent, \n  MacieJobLogEvent, \n  MacieJobStatusEventDetail \n} from './types/cloudwatch-logs-event';\nimport { MacieEventProcessor } from './utils/event-processor';\nimport { Logger } from '../shared/utils/logger';\nimport { EventBridgeValidator } from '../shared/utils/eventbridge-validator';\n\n/**\n * AWS Lambda handler for processing Macie job status events from CloudWatch Logs\n * \n * This function:\n * 1. Decodes CloudWatch Logs subscription filter events\n * 2. Parses Macie job log events\n * 3. Retrieves full job details from Macie API\n * 4. Extracts EventBus ARN from job tags\n * 5. Publishes enriched events to EventBridge\n */\nexport const handler = async (\n  event: CloudWatchLogsEvent,\n  context: Context\n): Promise<void> => {\n  const startTime = Date.now();\n  \n  // Initialize logger with context\n  const logger = new Logger({\n    requestId: context.awsRequestId,\n    functionName: context.functionName,\n    functionVersion: context.functionVersion\n  });\n\n  logger.info('Lambda function started', {\n    functionName: context.functionName,\n    functionVersion: context.functionVersion,\n    remainingTimeInMillis: context.getRemainingTimeInMillis()\n  });\n\n  try {\n    // Step 1: Decode CloudWatch Logs data\n    logger.info('Decoding CloudWatch Logs data');\n    const eventProcessor = new MacieEventProcessor(logger);\n    const logsData = eventProcessor.decodeCloudWatchLogsData(event);\n\n    // Step 2: Parse Macie job log events\n    logger.info('Parsing Macie job log events');\n    const macieEvents = eventProcessor.parseMacieLogEvents(logsData);\n\n    if (macieEvents.length === 0) {\n      logger.info('No relevant Macie events found, exiting');\n      return;\n    }\n\n    // Step 3: Initialize AWS clients\n    logger.info('Initializing AWS clients');\n    const macieClient = new Macie2Client({\n      region: process.env.AWS_REGION || 'us-east-1'\n    });\n    \n    const eventBridgeClient = new EventBridgeClient({\n      region: process.env.AWS_REGION || 'us-east-1'\n    });\n\n    const eventBridgeValidator = new EventBridgeValidator(logger);\n\n    // Step 4: Process each Macie event\n    logger.info('Processing Macie events', { eventCount: macieEvents.length });\n    \n    for (const macieEvent of macieEvents) {\n      await processMacieEvent(\n        macieEvent,\n        macieClient,\n        eventBridgeClient,\n        eventBridgeValidator,\n        eventProcessor,\n        logger\n      );\n    }\n\n    // Log total execution time\n    logger.logTiming('ProcessMacieJobStatus Lambda execution', startTime);\n    \n    logger.info('Successfully processed all Macie events');\n\n  } catch (error: any) {\n    logger.error('Unexpected error in Lambda execution', error);\n    throw error; // Re-throw to fail Lambda execution\n  }\n};\n\n/**\n * Process a single Macie job event\n */\nasync function processMacieEvent(\n  macieEvent: MacieJobLogEvent,\n  macieClient: Macie2Client,\n  eventBridgeClient: EventBridgeClient,\n  eventBridgeValidator: EventBridgeValidator,\n  eventProcessor: MacieEventProcessor,\n  logger: Logger\n): Promise<void> {\n  const jobId = macieEvent.jobId;\n  \n  logger.info('Processing Macie event', {\n    eventType: macieEvent.eventType,\n    jobId: jobId,\n    jobName: macieEvent.jobName\n  });\n\n  try {\n    // Step 1: Get full job details from Macie API\n    logger.info('Retrieving Macie job details', { jobId });\n    const jobDetailsStartTime = Date.now();\n    \n    let jobDetails;\n    try {\n      const describeJobCommand = new DescribeClassificationJobCommand({\n        jobId: jobId\n      });\n      \n      const response = await macieClient.send(describeJobCommand);\n      jobDetails = response;\n      \n      logger.logApiResponse('Macie2', 'DescribeClassificationJob', response, Date.now() - jobDetailsStartTime);\n    } catch (macieError: any) {\n      logger.error('Macie API call failed - failing execution', macieError, {\n        jobId: jobId,\n        eventType: macieEvent.eventType\n      });\n      \n      // Throw error to fail Lambda execution as per requirements\n      throw new Error(`Failed to retrieve Macie job details for ${jobId}: ${macieError.message}`);\n    }\n\n    // Step 2: Extract EventBus ARN from job tags\n    const eventBusArn = eventBridgeValidator.findEventBusArnTag(jobDetails.tags);\n    \n    if (!eventBusArn) {\n      logger.error('JobStatusEventBusArn tag not found in Macie job', undefined, {\n        jobId: jobId,\n        availableTags: jobDetails.tags ? Object.keys(jobDetails.tags) : []\n      });\n      \n      // Log error but continue processing (don't fail execution for missing tag)\n      return;\n    }\n\n    logger.info('Found JobStatusEventBusArn tag', { \n      jobId: jobId,\n      eventBusArn: eventBusArn \n    });\n\n    // Step 3: Validate EventBus exists\n    const validationResult = await eventBridgeValidator.validateEventBusArn(eventBusArn);\n    \n    if (!validationResult.isValid) {\n      logger.error('EventBus validation failed', undefined, {\n        jobId: jobId,\n        eventBusArn: eventBusArn,\n        validationError: validationResult.error\n      });\n      \n      // Log error but continue processing (don't fail execution for invalid EventBus)\n      return;\n    }\n\n    logger.info('EventBus validation successful', {\n      jobId: jobId,\n      eventBusArn: eventBusArn,\n      eventBusName: validationResult.eventBusName\n    });\n\n    // Step 4: Prepare EventBridge event\n    const eventCategory = eventProcessor.classifyEventType(macieEvent.eventType);\n    \n    const eventDetail: MacieJobStatusEventDetail = {\n      // Copy all original log data\n      ...macieEvent,\n      \n      // Add enriched job details\n      jobDetails: {\n        jobArn: jobDetails.jobArn || '',\n        name: jobDetails.name || '',\n        description: jobDetails.description,\n        s3JobDefinition: jobDetails.s3JobDefinition,\n        statistics: jobDetails.statistics,\n        tags: jobDetails.tags\n      },\n      \n      // Add processing metadata\n      eventCategory: eventCategory,\n      processedAt: new Date().toISOString()\n    };\n\n    // Step 5: Publish to EventBridge\n    logger.info('Publishing event to EventBridge', {\n      jobId: jobId,\n      eventBusArn: eventBusArn,\n      eventType: macieEvent.eventType,\n      eventCategory: eventCategory\n    });\n\n    const eventBusName = eventBridgeValidator.extractEventBusNameFromArn(eventBusArn);\n    \n    const putEventsCommand = new PutEventsCommand({\n      Entries: [\n        {\n          Source: 'macie.job.status',\n          DetailType: 'Macie Job Status Change',\n          Detail: JSON.stringify(eventDetail),\n          EventBusName: eventBusName!\n        }\n      ]\n    });\n\n    const publishStartTime = Date.now();\n    const publishResponse = await eventBridgeClient.send(putEventsCommand);\n    \n    logger.logApiResponse('EventBridge', 'PutEvents', publishResponse, Date.now() - publishStartTime);\n\n    // Check for failed entries\n    if (publishResponse.FailedEntryCount && publishResponse.FailedEntryCount > 0) {\n      logger.error('EventBridge publish had failed entries', undefined, {\n        jobId: jobId,\n        failedEntryCount: publishResponse.FailedEntryCount,\n        entries: publishResponse.Entries\n      });\n      \n      throw new Error(`Failed to publish event to EventBridge for job ${jobId}`);\n    }\n\n    logger.info('Successfully published event to EventBridge', {\n      jobId: jobId,\n      eventBusArn: eventBusArn,\n      eventId: publishResponse.Entries?.[0]?.EventId\n    });\n\n  } catch (error: any) {\n    logger.error('Error processing Macie event', error, {\n      jobId: jobId,\n      eventType: macieEvent.eventType\n    });\n    \n    // Re-throw to fail Lambda execution\n    throw error;\n  }\n}\n", "import * as zlib from 'zlib';\nimport { \n  CloudWatchLogsEvent, \n  CloudWatchLogsData, \n  MacieJobLogEvent, \n  MacieEventType,\n  COMPLETION_EVENT_TYPES,\n  ERROR_EVENT_TYPES \n} from '../types/cloudwatch-logs-event';\nimport { Logger } from '../../shared/utils/logger';\n\n/**\n * Utility class for processing CloudWatch Logs events from Macie\n */\nexport class MacieEventProcessor {\n  private logger: Logger;\n\n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n\n  /**\n   * Decode and decompress CloudWatch Logs data\n   */\n  decodeCloudWatchLogsData(event: CloudWatchLogsEvent): CloudWatchLogsData {\n    try {\n      // Decode base64\n      const compressed = Buffer.from(event.awslogs.data, 'base64');\n      \n      // Decompress gzip\n      const decompressed = zlib.gunzipSync(compressed);\n      \n      // Parse JSON\n      const logsData: CloudWatchLogsData = JSON.parse(decompressed.toString('utf8'));\n      \n      this.logger.debug('Successfully decoded CloudWatch Logs data', {\n        logGroup: logsData.logGroup,\n        logStream: logsData.logStream,\n        eventCount: logsData.logEvents.length\n      });\n      \n      return logsData;\n    } catch (error) {\n      this.logger.error('Failed to decode CloudWatch Logs data', error);\n      throw new Error(`Failed to decode CloudWatch Logs data: ${error}`);\n    }\n  }\n\n  /**\n   * Parse Macie job log events from CloudWatch log messages\n   */\n  parseMacieLogEvents(logsData: CloudWatchLogsData): MacieJobLogEvent[] {\n    const macieEvents: MacieJobLogEvent[] = [];\n\n    for (const logEvent of logsData.logEvents) {\n      try {\n        // Parse the JSON message\n        const macieLogEvent: MacieJobLogEvent = JSON.parse(logEvent.message);\n        \n        // Validate that this is a Macie job event we care about\n        if (this.isRelevantMacieEvent(macieLogEvent)) {\n          macieEvents.push(macieLogEvent);\n          \n          this.logger.info('Parsed relevant Macie job event', {\n            eventType: macieLogEvent.eventType,\n            jobId: macieLogEvent.jobId,\n            jobName: macieLogEvent.jobName\n          });\n        } else {\n          this.logger.debug('Skipping irrelevant Macie event', {\n            eventType: macieLogEvent.eventType\n          });\n        }\n      } catch (error) {\n        this.logger.error('Failed to parse log event message', error, {\n          logEventId: logEvent.id,\n          message: logEvent.message\n        });\n        // Continue processing other events instead of failing\n        continue;\n      }\n    }\n\n    this.logger.info('Parsed Macie log events', {\n      totalLogEvents: logsData.logEvents.length,\n      relevantMacieEvents: macieEvents.length\n    });\n\n    return macieEvents;\n  }\n\n  /**\n   * Determine if a Macie event is relevant for processing\n   */\n  private isRelevantMacieEvent(event: MacieJobLogEvent): boolean {\n    const eventType = event.eventType;\n    \n    // Check for completion events\n    if (COMPLETION_EVENT_TYPES.includes(eventType as any)) {\n      return true;\n    }\n    \n    // Check for specific error events\n    if (ERROR_EVENT_TYPES.includes(eventType as any)) {\n      return true;\n    }\n    \n    // Check for ACCOUNT_ prefixed events\n    if (eventType.startsWith('ACCOUNT_')) {\n      return true;\n    }\n    \n    // Check for BUCKET_ prefixed events\n    if (eventType.startsWith('BUCKET_')) {\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Classify event type as completion or error\n   */\n  classifyEventType(eventType: MacieEventType): 'completion' | 'error' {\n    // Check for completion events\n    if (COMPLETION_EVENT_TYPES.includes(eventType as any)) {\n      return 'completion';\n    }\n    \n    // All other relevant events are considered errors\n    return 'error';\n  }\n\n  /**\n   * Extract job ID from Macie log event\n   */\n  extractJobId(event: MacieJobLogEvent): string {\n    if (!event.jobId) {\n      throw new Error('Job ID not found in Macie log event');\n    }\n    return event.jobId;\n  }\n\n  /**\n   * Validate that required fields are present in Macie log event\n   */\n  validateMacieLogEvent(event: MacieJobLogEvent): void {\n    const requiredFields = ['eventType', 'jobId', 'adminAccountId', 'occuredAt'];\n    \n    for (const field of requiredFields) {\n      if (!event[field]) {\n        throw new Error(`Required field '${field}' missing from Macie log event`);\n      }\n    }\n  }\n}\n", "/**\n * CloudWatch Logs event types for Lambda function triggered by subscription filter\n */\n\nexport interface CloudWatchLogsEvent {\n  awslogs: {\n    data: string; // Base64 encoded and gzipped log data\n  };\n}\n\nexport interface CloudWatchLogsData {\n  messageType: string;\n  owner: string;\n  logGroup: string;\n  logStream: string;\n  subscriptionFilters: string[];\n  logEvents: CloudWatchLogEvent[];\n}\n\nexport interface CloudWatchLogEvent {\n  id: string;\n  timestamp: number;\n  message: string; // JSON string containing Macie log data\n}\n\n/**\n * Macie job log event structure from CloudWatch\n */\nexport interface MacieJobLogEvent {\n  eventType: string;\n  jobId: string;\n  adminAccountId: string;\n  occuredAt: string;\n  description: string;\n  jobName: string;\n  affectedAccount: string | undefined;\n  affectedResource: any | undefined;\n  operation: string | undefined;\n  runDate: string;\n  [key: string]: any; // Allow for additional fields from Macie logs\n}\n\n/**\n * EventBridge event structure for Macie job status\n */\nexport interface MacieJobStatusEvent {\n  source: string;\n  'detail-type': string;\n  detail: MacieJobStatusEventDetail;\n}\n\nexport interface MacieJobStatusEventDetail extends MacieJobLogEvent {\n  // Original log data is spread here\n  \n  // Additional enriched data\n  jobDetails?: {\n    jobArn: string;\n    name: string;\n    description?: string;\n    s3JobDefinition: any;\n    statistics?: any;\n    tags?: Record<string, string>;\n  };\n  \n  // Processing metadata\n  eventCategory: 'completion' | 'error';\n  processedAt: string;\n}\n\n/**\n * Event type classification\n */\nexport const COMPLETION_EVENT_TYPES = [\n  'SCHEDULED_RUN_COMPLETED',\n  'JOB_COMPLETED'\n] as const;\n\nexport const ERROR_EVENT_TYPES = [\n  'NO_BUCKETS_MATCHED_THE_CRITERIA',\n  'JOB_CANCELLED'\n] as const;\n\nexport type CompletionEventType = typeof COMPLETION_EVENT_TYPES[number];\nexport type ErrorEventType = typeof ERROR_EVENT_TYPES[number];\nexport type MacieEventType = CompletionEventType | ErrorEventType | string;\n", "/**\n * Logger utility for detailed parameter logging in Lambda functions\n */\n\nexport interface LogContext {\n  requestId: string;\n  functionName?: string;\n  functionVersion?: string;\n}\n\nexport class Logger {\n  private context: LogContext;\n\n  constructor(context: LogContext) {\n    this.context = context;\n  }\n\n  /**\n   * Log info level messages with detailed context\n   */\n  info(message: string, data?: any): void {\n    const logEntry = {\n      level: 'INFO',\n      timestamp: new Date().toISOString(),\n      requestId: this.context.requestId,\n      functionName: this.context.functionName,\n      functionVersion: this.context.functionVersion,\n      message,\n      data: data ? this.sanitizeData(data) : undefined\n    };\n    \n    console.log(JSON.stringify(logEntry));\n  }\n\n  /**\n   * Log error level messages with detailed context\n   */\n  error(message: string, error?: Error | any, data?: any): void {\n    const logEntry = {\n      level: 'ERROR',\n      timestamp: new Date().toISOString(),\n      requestId: this.context.requestId,\n      functionName: this.context.functionName,\n      functionVersion: this.context.functionVersion,\n      message,\n      error: error ? {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n        ...error\n      } : undefined,\n      data: data ? this.sanitizeData(data) : undefined\n    };\n    \n    console.error(JSON.stringify(logEntry));\n  }\n\n  /**\n   * Log debug level messages with detailed context\n   */\n  debug(message: string, data?: any): void {\n    const logEntry = {\n      level: 'DEBUG',\n      timestamp: new Date().toISOString(),\n      requestId: this.context.requestId,\n      functionName: this.context.functionName,\n      functionVersion: this.context.functionVersion,\n      message,\n      data: data ? this.sanitizeData(data) : undefined\n    };\n    \n    console.log(JSON.stringify(logEntry));\n  }\n\n  /**\n   * Log API request details\n   */\n  logApiRequest(service: string, operation: string, parameters: any): void {\n    this.info(`${service} API Request: ${operation}`, {\n      service,\n      operation,\n      parameters: this.sanitizeData(parameters)\n    });\n  }\n\n  /**\n   * Log API response details\n   */\n  logApiResponse(service: string, operation: string, response: any, duration?: number): void {\n    this.info(`${service} API Response: ${operation}`, {\n      service,\n      operation,\n      duration: duration ? `${duration}ms` : undefined,\n      response: this.sanitizeData(response)\n    });\n  }\n\n  /**\n   * Log execution timing\n   */\n  logTiming(operation: string, startTime: number): void {\n    const duration = Date.now() - startTime;\n    this.info(`Operation completed: ${operation}`, {\n      operation,\n      duration: `${duration}ms`\n    });\n  }\n\n  /**\n   * Sanitize sensitive data for logging\n   * Remove or mask sensitive information\n   */\n  private sanitizeData(data: any): any {\n    if (!data) return data;\n    \n    // Create a deep copy to avoid modifying the original\n    const sanitized = JSON.parse(JSON.stringify(data));\n    \n    // List of sensitive keys to mask\n    const sensitiveKeys = [\n      'password',\n      'secret',\n      'token',\n      'key',\n      'authorization',\n      'auth',\n      'credential',\n      'clientToken'\n    ];\n    \n    return this.maskSensitiveFields(sanitized, sensitiveKeys);\n  }\n\n  /**\n   * Recursively mask sensitive fields in an object\n   */\n  private maskSensitiveFields(obj: any, sensitiveKeys: string[]): any {\n    if (typeof obj !== 'object' || obj === null) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.maskSensitiveFields(item, sensitiveKeys));\n    }\n\n    const result: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const lowerKey = key.toLowerCase();\n      const isSensitive = sensitiveKeys.some(sensitiveKey => \n        lowerKey.includes(sensitiveKey.toLowerCase())\n      );\n\n      if (isSensitive && typeof value === 'string') {\n        result[key] = '***MASKED***';\n      } else if (typeof value === 'object') {\n        result[key] = this.maskSensitiveFields(value, sensitiveKeys);\n      } else {\n        result[key] = value;\n      }\n    }\n\n    return result;\n  }\n}\n", "import { EventBridgeClient, DescribeEventBusCommand } from '@aws-sdk/client-eventbridge';\nimport { Logger } from './logger';\n\n/**\n * EventBridge validation utilities\n */\n\nexport interface EventBusValidationResult {\n  isValid: boolean;\n  eventBusName?: string;\n  error?: string;\n}\n\nexport class EventBridgeValidator {\n  private client: EventBridgeClient;\n  private logger: Logger;\n\n  constructor(logger: Logger, region?: string) {\n    this.logger = logger;\n    this.client = new EventBridgeClient({\n      region: region || process.env.AWS_REGION || 'us-east-1'\n    });\n  }\n\n  /**\n   * Validate EventBridge ARN format\n   */\n  validateEventBusArnFormat(arn: string): boolean {\n    const eventBusArnPattern = /^arn:aws:events:[a-z0-9-]+:\\d{12}:event-bus\\/[a-zA-Z0-9._-]+$/;\n    return eventBusArnPattern.test(arn);\n  }\n\n  /**\n   * Extract event bus name from ARN\n   */\n  extractEventBusNameFromArn(arn: string): string | null {\n    const match = arn.match(/^arn:aws:events:[a-z0-9-]+:\\d{12}:event-bus\\/(.+)$/);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Check if EventBus exists by calling AWS API\n   */\n  async validateEventBusExists(eventBusName: string): Promise<EventBusValidationResult> {\n    try {\n      this.logger.info('Validating EventBus existence', { eventBusName });\n      \n      const command = new DescribeEventBusCommand({\n        Name: eventBusName\n      });\n\n      const response = await this.client.send(command);\n      \n      if (response.Name) {\n        this.logger.info('EventBus validation successful', { \n          eventBusName: response.Name,\n          eventBusArn: response.Arn \n        });\n        \n        return {\n          isValid: true,\n          eventBusName: response.Name\n        };\n      } else {\n        return {\n          isValid: false,\n          error: 'EventBus response missing name'\n        };\n      }\n    } catch (error: any) {\n      this.logger.error('EventBus validation failed', error, { eventBusName });\n      \n      return {\n        isValid: false,\n        error: error.message || 'Failed to validate EventBus'\n      };\n    }\n  }\n\n  /**\n   * Find EventBus ARN tag (case-insensitive)\n   */\n  findEventBusArnTag(tags: Record<string, string> | undefined): string | null {\n    if (!tags) {\n      return null;\n    }\n\n    // Search for the tag key case-insensitively\n    const targetKey = 'jobstatuseventbusarn';\n    \n    for (const [key, value] of Object.entries(tags)) {\n      if (key.toLowerCase() === targetKey) {\n        return value;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Complete validation: format + existence check\n   */\n  async validateEventBusArn(arn: string): Promise<EventBusValidationResult> {\n    // Step 1: Validate ARN format\n    if (!this.validateEventBusArnFormat(arn)) {\n      return {\n        isValid: false,\n        error: 'Invalid EventBridge ARN format. Expected: arn:aws:events:region:account:event-bus/name'\n      };\n    }\n\n    // Step 2: Extract event bus name\n    const eventBusName = this.extractEventBusNameFromArn(arn);\n    if (!eventBusName) {\n      return {\n        isValid: false,\n        error: 'Could not extract EventBus name from ARN'\n      };\n    }\n\n    // Step 3: Check if EventBus exists\n    return await this.validateEventBusExists(eventBusName);\n  }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "handler", "__toCommonJS", "import_client_macie2", "import_client_eventbridge", "zlib", "COMPLETION_EVENT_TYPES", "ERROR_EVENT_TYPES", "MacieEventProcessor", "__name", "logger", "event", "compressed", "decompressed", "logsData", "error", "macieEvents", "logEvent", "macieLogEvent", "eventType", "COMPLETION_EVENT_TYPES", "ERROR_EVENT_TYPES", "requiredFields", "field", "Logger", "__name", "context", "message", "data", "logEntry", "error", "service", "operation", "parameters", "response", "duration", "startTime", "sanitized", "sensitiveKeys", "obj", "item", "result", "key", "value", "lowerKey", "sensitiveKey", "import_client_eventbridge", "EventBridgeValidator", "__name", "logger", "region", "arn", "match", "eventBusName", "command", "response", "error", "tags", "targetKey", "key", "value", "handler", "__name", "event", "context", "startTime", "logger", "Logger", "eventProcessor", "MacieEventProcessor", "logsData", "macieEvents", "macieClient", "eventBridgeClient", "eventBridgeValidator", "EventBridgeValidator", "macieEvent", "processMacieEvent", "error", "jobId", "jobDetailsStartTime", "jobDetails", "describeJobCommand", "response", "macieError", "eventBusArn", "validationResult", "eventCategory", "eventDetail", "eventBusName", "putEventsCommand", "publishStartTime", "publishResponse"]
}
