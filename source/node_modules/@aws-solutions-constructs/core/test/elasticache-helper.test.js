"use strict";
/**
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance
 *  with the License. A copy of the License is located at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES
 *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions
 *  and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const assertions_1 = require("aws-cdk-lib/assertions");
const test_helper_1 = require("./test-helper");
const cdk = require("aws-cdk-lib");
const ec2 = require("aws-cdk-lib/aws-ec2");
const elasticache_helper_1 = require("../lib/elasticache-helper");
const elasticache_defaults_1 = require("../lib/elasticache-defaults");
test("Test returning existing Cache", () => {
    const stack = new cdk.Stack();
    const testVpc = (0, test_helper_1.getTestVpc)(stack, false);
    const existingCache = (0, test_helper_1.CreateTestCache)(stack, 'test', testVpc);
    const securityGroup = new ec2.SecurityGroup(stack, 'test-sg', {
        vpc: testVpc
    });
    const obtainedCache = (0, elasticache_helper_1.obtainMemcachedCluster)(stack, 'test-cache', {
        existingCache,
        cacheSecurityGroupId: securityGroup.securityGroupId
    });
    expect(obtainedCache).toBe(existingCache);
});
test("Test create cache with no client props", () => {
    const stack = new cdk.Stack();
    const testVpc = (0, test_helper_1.getTestVpc)(stack, false);
    const securityGroup = new ec2.SecurityGroup(stack, 'test-sg', {
        vpc: testVpc
    });
    (0, elasticache_helper_1.obtainMemcachedCluster)(stack, 'test-cache', {
        vpc: testVpc,
        cacheSecurityGroupId: securityGroup.securityGroupId,
        cachePort: 11111,
    });
    const template = assertions_1.Template.fromStack(stack);
    template.hasResourceProperties("AWS::ElastiCache::CacheCluster", {
        Port: 11111,
        AZMode: 'cross-az',
        Engine: 'memcached',
    });
});
test("Test create cache with client props", () => {
    const stack = new cdk.Stack();
    const testVpc = (0, test_helper_1.getTestVpc)(stack, false);
    const securityGroup = new ec2.SecurityGroup(stack, 'test-sg', {
        vpc: testVpc
    });
    (0, elasticache_helper_1.obtainMemcachedCluster)(stack, 'test-cache', {
        vpc: testVpc,
        cacheSecurityGroupId: securityGroup.securityGroupId,
        cachePort: 12321,
        cacheProps: {
            azMode: 'single-az',
            clusterName: 'test-name'
        }
    });
    const template = assertions_1.Template.fromStack(stack);
    template.hasResourceProperties("AWS::ElastiCache::CacheCluster", {
        Port: 12321,
        AZMode: 'single-az',
        Engine: 'memcached',
        ClusterName: 'test-name'
    });
});
test("Test GetCachePort() with existing cache", () => {
    const stack = new cdk.Stack();
    const testVpc = (0, test_helper_1.getTestVpc)(stack, false);
    const existingCache = (0, test_helper_1.CreateTestCache)(stack, 'test', testVpc, 32123);
    const port = (0, elasticache_helper_1.getCachePort)(undefined, existingCache);
    // Since the port from the existing cache is a token,
    // we can't check it directly, but we can ensure
    // the default port was replaced
    expect(port).not.toEqual((0, elasticache_defaults_1.GetDefaultCachePort)());
});
test("Test GetCachePort() with clientCacheProps", () => {
    const clientPort = 32123;
    const port = (0, elasticache_helper_1.getCachePort)({ port: clientPort });
    expect(port).toEqual(clientPort);
});
test("Test GetCachePort() with default port", () => {
    const port = (0, elasticache_helper_1.getCachePort)();
    expect(port).toEqual((0, elasticache_defaults_1.GetDefaultCachePort)());
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxhc3RpY2FjaGUtaGVscGVyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJlbGFzdGljYWNoZS1oZWxwZXIudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7O0dBV0c7O0FBRUgsdURBQWtEO0FBQ2xELCtDQUE0RDtBQUM1RCxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDLGtFQUFpRjtBQUNqRixzRUFBa0U7QUFFbEUsSUFBSSxDQUFDLCtCQUErQixFQUFFLEdBQUcsRUFBRTtJQUN6QyxNQUFNLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUU5QixNQUFNLE9BQU8sR0FBRyxJQUFBLHdCQUFVLEVBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3pDLE1BQU0sYUFBYSxHQUFHLElBQUEsNkJBQWUsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTlELE1BQU0sYUFBYSxHQUFHLElBQUksR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFO1FBQzVELEdBQUcsRUFBRSxPQUFPO0tBQ2IsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxhQUFhLEdBQUcsSUFBQSwyQ0FBc0IsRUFBQyxLQUFLLEVBQUUsWUFBWSxFQUFFO1FBQ2hFLGFBQWE7UUFDYixvQkFBb0IsRUFBRSxhQUFhLENBQUMsZUFBZTtLQUNwRCxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLHdDQUF3QyxFQUFFLEdBQUcsRUFBRTtJQUNsRCxNQUFNLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUU5QixNQUFNLE9BQU8sR0FBRyxJQUFBLHdCQUFVLEVBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBRXpD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WSxHQUFFLENBQUM7SUFDNUIsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFBLDBDQUFtQixHQUFFLENBQUMsQ0FBQztBQUM5QyxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpLiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4gKiAgd2l0aCB0aGUgTGljZW5zZS4gQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBvciBpbiB0aGUgJ2xpY2Vuc2UnIGZpbGUgYWNjb21wYW55aW5nIHRoaXMgZmlsZS4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICdBUyBJUycgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFU1xuICogIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG4gKiAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFRlbXBsYXRlIH0gZnJvbSAnYXdzLWNkay1saWIvYXNzZXJ0aW9ucyc7XG5pbXBvcnQgeyBDcmVhdGVUZXN0Q2FjaGUsIGdldFRlc3RWcGMgfSBmcm9tIFwiLi90ZXN0LWhlbHBlclwiO1xuaW1wb3J0ICogYXMgY2RrIGZyb20gJ2F3cy1jZGstbGliJztcbmltcG9ydCAqIGFzIGVjMiBmcm9tICdhd3MtY2RrLWxpYi9hd3MtZWMyJztcbmltcG9ydCB7IGdldENhY2hlUG9ydCwgb2J0YWluTWVtY2FjaGVkQ2x1c3RlciB9IGZyb20gXCIuLi9saWIvZWxhc3RpY2FjaGUtaGVscGVyXCI7XG5pbXBvcnQgeyBHZXREZWZhdWx0Q2FjaGVQb3J0IH0gZnJvbSBcIi4uL2xpYi9lbGFzdGljYWNoZS1kZWZhdWx0c1wiO1xuXG50ZXN0KFwiVGVzdCByZXR1cm5pbmcgZXhpc3RpbmcgQ2FjaGVcIiwgKCkgPT4ge1xuICBjb25zdCBzdGFjayA9IG5ldyBjZGsuU3RhY2soKTtcblxuICBjb25zdCB0ZXN0VnBjID0gZ2V0VGVzdFZwYyhzdGFjaywgZmFsc2UpO1xuICBjb25zdCBleGlzdGluZ0NhY2hlID0gQ3JlYXRlVGVzdENhY2hlKHN0YWNrLCAndGVzdCcsIHRlc3RWcGMpO1xuXG4gIGNvbnN0IHNlY3VyaXR5R3JvdXAgPSBuZXcgZWMyLlNlY3VyaXR5R3JvdXAoc3RhY2ssICd0ZXN0LXNnJywge1xuICAgIHZwYzogdGVzdFZwY1xuICB9KTtcbiAgY29uc3Qgb2J0YWluZWRDYWNoZSA9IG9idGFpbk1lbWNhY2hlZENsdXN0ZXIoc3RhY2ssICd0ZXN0LWNhY2hlJywge1xuICAgIGV4aXN0aW5nQ2FjaGUsXG4gICAgY2FjaGVTZWN1cml0eUdyb3VwSWQ6IHNlY3VyaXR5R3JvdXAuc2VjdXJpdHlHcm91cElkXG4gIH0pO1xuXG4gIGV4cGVjdChvYnRhaW5lZENhY2hlKS50b0JlKGV4aXN0aW5nQ2FjaGUpO1xufSk7XG5cbnRlc3QoXCJUZXN0IGNyZWF0ZSBjYWNoZSB3aXRoIG5vIGNsaWVudCBwcm9wc1wiLCAoKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IGNkay5TdGFjaygpO1xuXG4gIGNvbnN0IHRlc3RWcGMgPSBnZXRUZXN0VnBjKHN0YWNrLCBmYWxzZSk7XG5cbiAgY29uc3Qgc2VjdXJpdHlHcm91cCA9IG5ldyBlYzIuU2VjdXJpdHlHcm91cChzdGFjaywgJ3Rlc3Qtc2cnLCB7XG4gICAgdnBjOiB0ZXN0VnBjXG4gIH0pO1xuICBvYnRhaW5NZW1jYWNoZWRDbHVzdGVyKHN0YWNrLCAndGVzdC1jYWNoZScsIHtcbiAgICB2cGM6IHRlc3RWcGMsXG4gICAgY2FjaGVTZWN1cml0eUdyb3VwSWQ6IHNlY3VyaXR5R3JvdXAuc2VjdXJpdHlHcm91cElkLFxuICAgIGNhY2hlUG9ydDogMTExMTEsXG4gIH0pO1xuXG4gIGNvbnN0IHRlbXBsYXRlID0gVGVtcGxhdGUuZnJvbVN0YWNrKHN0YWNrKTtcbiAgdGVtcGxhdGUuaGFzUmVzb3VyY2VQcm9wZXJ0aWVzKFwiQVdTOjpFbGFzdGlDYWNoZTo6Q2FjaGVDbHVzdGVyXCIsIHtcbiAgICBQb3J0OiAxMTExMSxcbiAgICBBWk1vZGU6ICdjcm9zcy1heicsXG4gICAgRW5naW5lOiAnbWVtY2FjaGVkJyxcbiAgfSk7XG59KTtcblxudGVzdChcIlRlc3QgY3JlYXRlIGNhY2hlIHdpdGggY2xpZW50IHByb3BzXCIsICgpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSBuZXcgY2RrLlN0YWNrKCk7XG5cbiAgY29uc3QgdGVzdFZwYyA9IGdldFRlc3RWcGMoc3RhY2ssIGZhbHNlKTtcblxuICBjb25zdCBzZWN1cml0eUdyb3VwID0gbmV3IGVjMi5TZWN1cml0eUdyb3VwKHN0YWNrLCAndGVzdC1zZycsIHtcbiAgICB2cGM6IHRlc3RWcGNcbiAgfSk7XG4gIG9idGFpbk1lbWNhY2hlZENsdXN0ZXIoc3RhY2ssICd0ZXN0LWNhY2hlJywge1xuICAgIHZwYzogdGVzdFZwYyxcbiAgICBjYWNoZVNlY3VyaXR5R3JvdXBJZDogc2VjdXJpdHlHcm91cC5zZWN1cml0eUdyb3VwSWQsXG4gICAgY2FjaGVQb3J0OiAxMjMyMSxcbiAgICBjYWNoZVByb3BzOiB7XG4gICAgICBhek1vZGU6ICdzaW5nbGUtYXonLFxuICAgICAgY2x1c3Rlck5hbWU6ICd0ZXN0LW5hbWUnXG4gICAgfVxuICB9KTtcblxuICBjb25zdCB0ZW1wbGF0ZSA9IFRlbXBsYXRlLmZyb21TdGFjayhzdGFjayk7XG4gIHRlbXBsYXRlLmhhc1Jlc291cmNlUHJvcGVydGllcyhcIkFXUzo6RWxhc3RpQ2FjaGU6OkNhY2hlQ2x1c3RlclwiLCB7XG4gICAgUG9ydDogMTIzMjEsXG4gICAgQVpNb2RlOiAnc2luZ2xlLWF6JyxcbiAgICBFbmdpbmU6ICdtZW1jYWNoZWQnLFxuICAgIENsdXN0ZXJOYW1lOiAndGVzdC1uYW1lJ1xuICB9KTtcbn0pO1xuXG50ZXN0KFwiVGVzdCBHZXRDYWNoZVBvcnQoKSB3aXRoIGV4aXN0aW5nIGNhY2hlXCIsICgpID0+IHtcblxuICBjb25zdCBzdGFjayA9IG5ldyBjZGsuU3RhY2soKTtcblxuICBjb25zdCB0ZXN0VnBjID0gZ2V0VGVzdFZwYyhzdGFjaywgZmFsc2UpO1xuICBjb25zdCBleGlzdGluZ0NhY2hlID0gQ3JlYXRlVGVzdENhY2hlKHN0YWNrLCAndGVzdCcsIHRlc3RWcGMsIDMyMTIzKTtcblxuICBjb25zdCBwb3J0ID0gZ2V0Q2FjaGVQb3J0KHVuZGVmaW5lZCwgZXhpc3RpbmdDYWNoZSk7XG5cbiAgLy8gU2luY2UgdGhlIHBvcnQgZnJvbSB0aGUgZXhpc3RpbmcgY2FjaGUgaXMgYSB0b2tlbixcbiAgLy8gd2UgY2FuJ3QgY2hlY2sgaXQgZGlyZWN0bHksIGJ1dCB3ZSBjYW4gZW5zdXJlXG4gIC8vIHRoZSBkZWZhdWx0IHBvcnQgd2FzIHJlcGxhY2VkXG4gIGV4cGVjdChwb3J0KS5ub3QudG9FcXVhbChHZXREZWZhdWx0Q2FjaGVQb3J0KCkpO1xufSk7XG5cbnRlc3QoXCJUZXN0IEdldENhY2hlUG9ydCgpIHdpdGggY2xpZW50Q2FjaGVQcm9wc1wiLCAoKSA9PiB7XG4gIGNvbnN0IGNsaWVudFBvcnQgPSAzMjEyMztcblxuICBjb25zdCBwb3J0ID0gZ2V0Q2FjaGVQb3J0KHsgcG9ydDogY2xpZW50UG9ydCB9KTtcbiAgZXhwZWN0KHBvcnQpLnRvRXF1YWwoY2xpZW50UG9ydCk7XG59KTtcbnRlc3QoXCJUZXN0IEdldENhY2hlUG9ydCgpIHdpdGggZGVmYXVsdCBwb3J0XCIsICgpID0+IHtcblxuICBjb25zdCBwb3J0ID0gZ2V0Q2FjaGVQb3J0KCk7XG4gIGV4cGVjdChwb3J0KS50b0VxdWFsKEdldERlZmF1bHRDYWNoZVBvcnQoKSk7XG59KTtcbiJdfQ==